# 模拟面试.
1h.
### React. 
1、虚拟dom 的原理是什么?
    1.用Javascript 对象结构表示DOM树的结构; 然后用这个树构建一个真正的DOM树,插入到文档当中。
    2.当状态变更的时候，重新构造一颗新的对象树。然后用新的树和旧的树进行比较，记录两颗树的差异。
    3.把2所记录的差异应用到步骤1所构建的真正的DOM树上,视图就更新了.

2、ref 用过吗?
    1、用过, ref用于访问 render 方法中创建 dom 元素或者是 React 组件的实例.
    2、ref 有三种用法, string ref,call back ref,createRef.
    3、推荐使用:createRef.callback ref 不推荐使用 string ref.
    为什么不推荐使用ref?
    1、当 ref 定义为string 时,需要 React 追踪当前正在渲染的组件,在 reconciliation 阶段, React Element 创建.
    和更新的过程中, ref 会被包装为一个闭包函数, 等待 commit 阶段被执行，这会对React 的性能产生一些影响.
    2、当使用 render callback 模式的时候,使用 string ref 会造成 ref 挂载位置产生歧义.

3、Context 用过吗?
    new Context vs Context 什么区别?
    https://www.zhihu.com/question/267168180/answer/324650336.
    Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法

4、中间件用过哪些? 中间件的原理是什么?
    3、中间件的基本原理:
    中间件的原理是,它提供的是被发起之后,到达reducer 之前的扩展点.将store.dispatch方法进行替换.

4、编写中间件的步骤:
    测试.

5、中间件原理分析:
    要实现一套middleware 主要分为3步: 
    第一步串联 middleware. currying 化.
    const middlewareAPI = {
    getState: store.getState,
    dispatch: (action) => dispatch(action),
    };
    chain = middlewares.map(middleware => middleware(middlewareAPI));

    第二步组合 middleware.
    dispatch = compose(...chain)(store.dispatch);

    组合函数:
    function compose(...funcs) {
        return arg => funcs.reduceRight((composed, f) => f(composed), arg); 6
    }

    组合完成之后:
    dispatch = f1(f2(f3(store.dispatch))));

    这时调用新 dispatch,每一个 middleware 就依次执行了。

    第三步调用执行.
    当我们分发一个 action 时,middleware 通过 next(action) 一层层处理和传递 action 直到 Redux 原生的 dispatch.

6、如何实现中间件:
```
function createThunkMiddleware(extraArgument){
    return ({dispatch,getState}) => next => action =>{
        if(typeof action === 'function'){
            return action(dispatch,getState,extraArgument);
        }
        return next(action);
    }
}
```

1、原理 (principle)
    工作流程:
    ![image](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg)

    描述一下: 
      * 组件的状态发生改变，会触发store.dispatch 分发 action,reducers 接收到action 会返回newState,最终会把这个newState 返回给 React.Component.

2、 三大原则:
      1、单一数据源.
        在传统的MVC架构中,我们可以根据需要创建无数个Model,而Model之间可以互相监听、 触发事件甚至循环或嵌套触发事件,这些在 Redux 中都是不允许的.
      2、State是只读的.
      3、使用纯函数来执行修改.
        * 这是Redux与Flux 在表现上的最大不同。在 Flux 中,我们在actionCreator里调用 AppDispatcher.dispatch 方法来触发 action,这样不仅有冗余的代码,而且因为直接修改了 store 中 的数据,将导致无法保存每次数据变化前后的状态.
        * 在 Redux 里,我们通过定义 reducer 来确定状态的修改,而每一个 reducer 都是纯函数,这意 味着它没有副作用,即接受一定的输入,必定会得到一定的输出。
        这样设计的好处不仅在于 reducer 里对状态的修改变得简单、纯粹、可测试,更有意思的是, Redux 利用每次新返回的状态生成酷炫的时间旅行(time travel)调试方式,让跟踪每一次因为触发 action 而改变状态的结果成为了可能.

Redux 
多个store 怎么搞?

5、你们是怎么做并行请求的?

async await.

gennerate 语法要了解一下.

6、高阶组件用过吗?
高阶组件本质是一个高阶函数，最大的好处是解耦和灵活性.

怎么使用:
1、抽取公用代码和业务逻辑.功能和页面类似的页面，可以把一些共同的操作抽离到HOC组件中
2、抽离state. react 处理表单的时候，如果使用了受控组件，可以把onChange 事件同步改变state 的代码，封装到高阶组件中,还有提交的事件。
3、劫持渲染.(loading 动效,页面权限管理)。
4、操作props,增加用户信息属性对象.
5、反向继承. 场景:两个页面的相似度非常高，要新加一些属性的时候可以考虑使用.

卡壳的地方: renderprops 是用来解决什么问题? 高阶组件解决什么问题? 是怎么解决的?

7、purecomponent & component 有什么区别?
    1、PureComponent 继承了 Component。但是在原型链式扩展了 isPureComponent 的属性.
    2、有 isPureComponent  的属性会进行浅比较.

    浅比较是怎么实现的?
    1、是比较两个对象是否相等. 源码是通过Object.is 方法来实现的. 比较的是对象是否相等. 但是没有比较多层嵌套的对象以及函数.
    如何实现:
    1、通过判断基本数据类型. Object.is 
    2、判断两个对象的长度是否一致。
    3、然后通过循环的方式判断两个对象是否相等

    React.Component 里面有啥?
    1、 setState.
    2、forceUpdate.
    3、state 的更新的入口.

    浅比较是怎么实现的?
    1、是比较两个对象是否相等. 源码是通过Object.is 方法来实现的,只对基本数据类型进行了比较,如果是数组类型，就会区分不出来变化,因为两次比较数组的引用没有发生变化.

    shouldComponentUpdate(nextProps, nextState){
        return !is(fromJS(this.props), fromJS(nextProps))|| !is(fromJS(this.state),fromJS(nextState))
    }

深克隆与浅克隆 对比分析.
immutable 对象.

8、设计一个dialog 你怎么设计?

9、react Fiber.

11、setState 干了什么?

12、时间分片,挂起.

 *  time Slice
        * 这个概念的背景是什么?
            * React 在渲染（render）的时候，不会阻塞现在的线程。
            * 如果你的设备足够快，你会感觉渲染是同步的。
            * 如果你设备非常慢，你会感觉还算是灵敏的。
            * 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来。
            * 
        * 可以在哪些场景下使用? 3个场景.
        * 优缺点是什么?
        * 如何在我的项目中使用?

        * 参考文献:
            * https://react-timeslicing-demo.netlify.com/
            * 验证登录权限 https://auth0.com/blog/time-slice-suspense-react16/
            * 
    *  Suspense
        * 主要解决什么问题?
            * Suspense主要解决的就是网络IO问题。网络IO问题其实就是我们现在用Redux+saga等等一系列乱七八糟的库来解决的「副作用」问题。
        * 可以在哪些场景下使用? 3个场景.
            * 引入新的api，可以使得任何state更新暂停，直到条件满足时，再渲染（像async/await）.
            * 可以在任何一个组件里放置异步获取数据，而不用做多余的设置
            * 在网速非常快的时候，可设置，整个数据到达Dom，更新完毕以后再渲染
            * 会给我们提供 high-level (createFetcher)和 low-level( ) 的 API，可以供给业务代码和一些小组件的书写。

* react 性能优化有哪些?

redux vs mbox vs dva 比较?

vue vs react 什么区别?
1h.

需要改进的地方:
1、理念说不清楚.

路由的基本原理是什么?

 计时.7:33 -  8:30

  22:17 -  
### Javascript
闭包.

原型链:

上下文执行环境.

call,bind,apply 什么区别?

作用域链: 不清楚是什么?

继承 描述不太清楚

jsonp 的原理是什么? 不记得.

### Css 

选择器:

优先级:

### 小程序
应用情况.

基本原理.

### 项目遇到的问题.
