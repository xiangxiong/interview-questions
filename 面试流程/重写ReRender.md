###  重写ReRender.md
Remax 虚拟dom 是如何渲染到小程序的?
1、HostConfig 的 createInstance 和 createTextInstance 方法.
2、


# 基本原理: 
小程序隔离了 渲染进程 和 逻辑进程。 Remax 是跑在 逻辑进程上的。
在逻辑进程 中无法进行实际的渲染，只能通过setData 方式将更新指令传递给渲染进程后，
在进行解析指令.

remax 选择在 逻辑进程中 先构成一颗 镜像树, 然后再同步到 渲染进程中,如下图:


## 镜像树的构建和操作.


## 节点更新.


## 副作用提交.
对于 Remax 来首, 什么时候应该将“更新” 提交至渲染进程呢? 答案是上图所在的 提交阶段 的方法被调用时.
提交阶段 原意是用于执行各种副作用的, 例如视图更新, 远程方法请求, 订阅.... 所以 Remax 
也会在这个阶段收集更新指令, 在下一个循环推送给渲染进程.


## HostConfig 执行流程总结.


## 同步到渲染进程.
* 1、React 自定义渲染器差不多就这样了, 接下来的就是平台相关的事情了。Remax 目前的做法是在触发更新后，通过
小程序page 对象的 setData 方法将 更新指令 传递给 渲染进程; 渲染进程侧面在通过 WXS 机制,
将 更新指令 回复到树中; 最好在通过模板机制, 将树递归渲染出来.

* 

## 总结:
### 自定义React 渲染器.

1、 Reconciler 和 Renderer 的关系可以通过下图缕清楚:

react-reconciler 这就是React 的协调器.

scheduler 合作调度器的一些API.

创建一个自定义渲染器只需要两步:
1、第一步: 实现宿主配置.这是react-reconciler要求宿主提供的一些适配器方法和配置项。这些配置项定义了如何创建节点实例、构建节点树、提交和更新等操作。下文会详细介绍这些配置项:

2、第二步：实现渲染函数. 类似于ReactDOM.render() 方法



### Remax 和 taro 的做法有什么不同?

1、Remax选择在逻辑进程中先构成一颗镜像树(Mirror Tree), 然后再同步到渲染进程中.


#### 镜像树的构建和操作.

#### 同步到渲染进程.
React 自定义渲染器差不多就这样了，接下来就是平台相关的事情了。 Remax 目前的做法是在触发更新后，通过小程序 Page 对象的 setData 方法将更新指令传递给渲染进程; 渲染进程侧再通过 WXS 机制，将更新指令恢复到树中； 最后再通过模板机制，将树递归渲染出来.

### 

参考文献:
https://zhuanlan.zhihu.com/p/83324871.










https://zhuanlan.zhihu.com/p/83324871



https://mp.weixin.qq.com/s/3QE3g0NmaBAi91lbrihhVw
