### tree shaking (摇树优化).
Tree-shaking 原理
   ES6 模块的特点:
   只能作为模块顶层的语句出现
   import 的模块名只能是常量字符串. 
   import binding 是 immutable的.

代码擦除: uglify 阶段删除无用代码

## 现象:构建后的代码存在大量闭包代码
会导致什么问题?
大量作用域包裹代码,导致体积增 (模块越多越明显).
运行代码时创建的函数作用域变多,内存开销变.

结论:
·被 webpack 转换后的模块会带上 层包裹 
·import 会被转换成 __webpack_require.
* 每个模块多会分配模块id.

## scope hoisting 原理.
原理:将所有模块的代码按照引用顺序放在一个函数作用域 ,然后适当的重命名 
些变量以防止变量名冲突.
必须是es6 语法.



webpack 热更新的原理是什么?

第一种方式:
webpack-dev-server 热更新原理.
wds 不刷新浏览器.
wds 不输出文件,而是放在内存中.
使用 HotModuleReplacementPlugin 插件.

第二种方式:
使用 webpack-dev-middleware 插件.
wdm 将webpack 输出的文件传输给服务器.

启动阶段:
Complier 将js 文件编译成 bundle.js
bundle.js 打包了 hmr runtime 可以让文件让服务的方式运行.

文件系统的变化:
1、文件打包之后发送给 HMR Server 知道了哪些模块发生了改变.
2、发生变化的文件传递给 Hmr runtime ，runtime 更新bundle.js 然后刷新浏览器.

webpack 打包的原理是什么?
1、初始化入口参数.
2、开始编译.
3、从entry 开始递归的分析依赖,对每个依赖模块进行build
4、对模块位置进行解析.
5、开始构建某个模块.
6、将loader 加载完成的module 进行编译，生成ast 树.
7、遍历AST,当遇到require 等一些调用表达式,收集依赖.
8、所有依赖build 完成,开始优化.
9、输出到dist 目录.

怎么手写一个webpack?
读取文件分析模块依赖
对模块进行解析执行(深度遍历)
针对不同的模块使用相应的loader
编译模块，生成抽象语法树AST。
循环遍历AST树，拼接输出js。


webpack loader 怎么写?
loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用.
首先明确你这个loader具备什么功能: 比如代码压缩功能.

html-minify-loader.js
var loaderUtils = require('loader-utils');
var Minimize = require('minimize');
module.exports = function(source) {
    var minimize = new Minimize();
    return minimize.parse(source);
};

webpack 3,4 有哪些区别?

### webpack 4.0 有哪些新特性?
1、到webpack-cli的改变.
2、更快的构建时间.
3、零配置模块打包.

```
Webpack 4不需要配置文件和入口文件。
Webpack 4 不需要任何配置文件，只要src/index.js文件。
```
4、用mode点燃火焰
```
production选项提供了一系列默认配置，它可以：

更小的输出尺寸
运行时的快速加载代码
省略只在开发时的代码
不暴露源代码或者路径
快捷使用输出assets

development选项提供了一下默认配置，它可以：
浏览器内调试更好的工具
在一个快速的开发周期，更快的增量编译
更好的运行时错误提示
```

5、新增了SplitChunksPlugin.
Webpack 4对块图进行了巨大改进，并使用了新的块拆分技术。在新的改进过程中，诞生了新的插件---SplitChunksPlugin。
这个插件能够自动识别哪些模块需要拆分为启发式的(heuristics)，哪些需要拆分为块。另外，它还有一些极好的特性，
比如在异步chunks的高效，以及把vender拆分成不同的vender块.

6、不再支持Node.js 4
建议用户使用Node >= 8.94，以便使用最优的性能，是因为源代码使用了JavaScript新特性.

多页打包怎么做?

-----------------------------------------------------------

webpack 知识点:
px2rem loader.
webpack loader 怎么写?
```

```
# 知识考点:
* css-loader  于加载 .css  件,并且转换成 commonjs 对象
* style-loader 将样式通过 <style> 标签插 到 head 中.
* npm i style-loader css-loader -D.
* webpack 执行是从右到左执行的，所以先写style-loader,css-loader.
* less-loader 用于将 less 转换成 css.

多页应用怎么做?

动态生成htmlwebpackplugin.

怎么分离公共库?
optimization: {
        splitChunks: { minSize: 0, cacheGroups: {
        commons: {
                    name: 'commons', 
                    chunks: 'all', 
                    minChunks: 0
                } 
            }
        }
}

怎么分离基础库:
SplitChunksPlugin:
```
    optimization: {
        splitChunks: { cacheGroups: {
        commons: {
        test: /(react|react-dom)/,
        name: 'vendors',
        chunks: 'all' }
        } }
    }
```

基础库可以动态加载?
```
 new HtmlWebpackExternalsPlugin({
        //     externals:[
        //         {
        //             module:'react',
        //             entry:'https://unpkg.com/react@16/umd/react.production.min.js',
        //             global:'React'
        //         },{
        //             module:'react-dom',
        //             entry:'https://unpkg.com/react-dom@16/umd/react-dom.production.min.js',
        //             global:'ReactDOM'
        //         }
        //     ]
  })
```

# 核心概念:
1.output.
2.entry.
3.loaders.
4.plugins.
5.Mode

### 分析考点:

## 多页打包怎么弄?
tree shaking(摇树优化):
Tree-shaking 原理
   ES6 模块的特点:
   只能作为模块顶层的语 出现.
   import 的模块名只能是字符 常.
   import binding 是 immutable的.
   代码擦除:uglify 阶段删除无用代码.

## scope hoisting 原理.
原 :将所有模块的代码按照引 顺序放在 个函数作 域 ,然后适当的重命名 
些变 以防 变 名冲突.

## 多页面方案:
动态获取 entry 和设置 html-webpack-plugin 数量.
利用 glob.sync 文件通用匹配的规则. 同步返回文件的路径.
遍历文件的数组:
利用正则匹配规则或者页面名称.
生成动态的htmlPlugins, 组合到Plugins.

----------------------------------------------------------- 

# 为什么么需要构建工具?

* 转换 ES6 语法.
* 转换 JSX.
* CSS 前缀补全/预处理.
* 压缩混淆.
* 图片压缩.

# 前端构建演变之路.
* rollup webpack.

# 为什么选择 webpack?

# 玩转 webpack?
* 

# 核心概念Entry
* Entry 用来来制定打包的入口.
    * 模拟依赖图.
    ( js,css,.jpg 多是模块.)
* webpack 核心概念之output.

单入口对象
```
module.exports = {
    entry:'./path/to/my/entry/file.js'
}
```

多入口: entry 是一个对象.

```
module.exports = {
    entry:{
        app:'./src/app.js',
        adminApp:'./src/adminApp.js'
    }
}
```

# 核心概念之 Output
Output 来告诉 webpack 如何将编译后的 件输出到磁盘.

```
 output:{
        path:path.join(__dirname,'dist'),
        filename:'[name].js'
    },
```

# 核心概念之 Loaders

```
webpack 开箱即用只支持 JS 和 JSON 两种文件类型,通过 Loaders 去支持其它文 件类型并且把它们转化成有效的模块,并且可以添加到依赖图中。

本身是一个函数,接受源文件作为参数,返回转换的结果。

loaders:

css-loader.
less-loader.
ts-loader.
raw-loader.
```

用法:

# 核心概念之 plugins.
插件 于 bundle  件的优化,资源管 和环境变注入.
作用于整个构建过程.

CommonsChunkPlugin 将chunks相同的模块代码提取成公共js.
cleanWebpackPlugin 清理构建目录.
UglifyjsWebpackPlugin 压缩js.
ExtracTextWebpackPlugin  将 css 从 bundle 文件里提取成一个独立的css 文件.
CommonsChunkPlugin  将chunks 相同的模块代码提取成公共js.
ZipWebpackPlugin 将打包的资源生成一个zip包.
CopyWebpackPlugin 将文件或者文件夹拷贝到构建的输出目录.

用法:

```

```

# 核心概念之 Mode.
Mode 用来指定当前的构建环境是: production、development 还是none.

设置 mode 可以使用 webpack 内置的函数,默认值为 production.

development.
NamedChunksPlugin

production.
FlagDependencyUsagePlugin.

none
不开启优化选项.

```

```

# 资源解析: 解析es6.
使用 babel-loader.
babel 的配置文件:.babelrc.

```
presets:

plugins:
```
npm i @babel/core @babel/preset-env babel-loadr -D

presets 是一系列 plugins 的集合.

# 资源解析:解析 React JSX.

npm i react react-dom @babel/preset-react -D

```
{
    "presets":[
        "@babel/preset-env",
        "@babel/preset-react"
    ]
}
```

# 资源解析:解析 CSS/less/sass.
* css-loader  于加载 .css  件,并且转换成 commonjs 对象
* style-loader 将样式通过 <style> 标签插 到 head 中.

* npm i style-loader css-loader -D.

* webpack 执行是从右到左执行的，所以先写style-loader,css-loader.

* less-loader 用于将 less 转换成 css.

npm i less less-loader -D

```
    {
        test:/.less$/,
        use:[
            'style-loader',
            'css-loader',
            'less-loader'
        ]   
    }
```

# 资源解析:解析图片 和字体资源.
* file-loader 用于处理文件.
* npm i file-loader -D.
```
    {
        test:/.(png|jpg|gif|jpeg)$/,
        use:'file-loader'
    }
```
* url-loader 也可以处图片和字体.
* 可以设置较小资源自动base64.

```
 {
                test:/.(png|jpg|gif|jpeg)$/,
                use:[
                    {
                        loader:'url-loader',
                        options:{
                            limit:10240
                        }
                    }
                ]
}
```

# 资源解析: webpack 中的文件的监听.
文件监听是在发现源码发 变化时, 动重新构建出新的输出 件。
webpack 开启监听模式,有两种方式: 
·启动 webpack 命令时,带上 --watch 参数 
·在配置 webpack.config.js 中设置 watch: true

```
 "watch": "webpack --watch"
```

文件监听的原理分析:
轮询判断 件的最后编辑时间是否变化
某个 件发  变化,并 会 刻告诉监听者, 是先缓存起来,等 aggregateTimeout

# 热更新:webpack-dev-server
WDS 不刷新浏览器.
WDS 不输出文件, 而是放在内存里面.
使  HotModuleReplacementPlugin插件。

```

npm i webpack-dev-server --save

```
# 热更新:使用webpack-dev-middleware
Webpack Compile: 将 JS 编译成 Bundle
HMR Rumtime: 会被注 到浏览 ,  新 件的变化
Bundle server: 提供 件在浏览 的访问
HMR Server: 将热 新的 件输出给 HMR Rumtime
。

# 什么是文件指纹?
打包后输出的文件名的后缀. 版本管理.

Hash:和整个项目的构建相关,只要项目文件有修改,整个项目构建的 hash 值就会改.

Chunkhash:和 webpack 打包的 chunk 有关, 同的 entry 会 成 同的 chunkhash 值

Contenthash:根据 件内容来定义 hash , 件内容 变,则 contenthash 改变. css 文件内容改变.

# 图片的文件指纹设置.

# mini-css-extract-plugin
npm i mini-css-extract-plugin -D
mini-css-extract-plugin 和 style-loader 功能是互斥的。不能一起使用。
mini-css-extract-plugin 将css 单独隔离到一个文件.

# 代码压缩.
HTML 压缩
npm i html-webpack-plugin -D

CSS 压缩.
cssnano.

optimize-css-assets-webpack-plugin

npm i optimize-css-assets-webpack-plugin -D

npm i cssnano -D

修改 html-webpack-plugin 设置压缩参数.

JS 压缩.
uglifyjs-webpack-plugin.

## 玩转 webpack :


## 当前构建时的问题
每次构建的时候 会清理录,造成构建的输出 录 output  件越来越多

rm -rf ./dist && webpack

npm i clean-webpack-plugin -D

const CleanWebPackPlugin = require('clean-webpack-plugin').CleanWebpackPlugin;

  new CleanWebPackPlugin()

# 23 CSS3 的属性为么需要前缀？


# Post Css 插件:
PostCSS 插件 autoprefixer 自动补  CSS3 前缀.

npm i postcss-loader autoprefixer -D

```
    loader:'postcss-loader',
        options:{
            plugins:()=>[
                    require('autoprefixer')({
                        browsers:['last 2 version','>1%','ios 7']
                    })
            ]
        }
    }
```

# rem 是什么?
移动端 CSS px 自动转换成rem
px2rem-loader.
npm i px2rem-loader -D
npm i lib-flexible -S
自适应方案的设计.

# 资源内联的方案.


# 多页面应用打包通用方案:
* npm i glob -D.
每 次  跳转的时候,后台服务 都会给返回 个新的 html  档, 这种类型的 站也就是多  站,也叫做多 应 .

缺点:每次新增或删除页面需要改 webpack 配置.

多页面方案:
动态获取 entry 和设置 html-webpack-plugin 数量.

利用 glob.sync 文件通用匹配的规则. 同步返回文件的路径.

遍历文件的数组:
利用正则匹配规则或者页面名称.
生成动态的htmlPlugins, 组合到Plugins.

# source map.
* 

## 提取页面的公共资源.

基础库分离.

SplitChunksPlugin:
```
    optimization: {
        splitChunks: { cacheGroups: {
        commons: {
        test: /(react|react-dom)/,
        name: 'vendors',
        chunks: 'all' }
        } }
    }
```

chunks 参数说明:
* async 异步引入的库进行分离(默认).
* initial 同步引入的库进行分离。
* all 所有引入的库进行分离.

引入cdn库:
```
  // new HtmlWebpackExternalsPlugin({
        //     externals:[
        //         {
        //             module:'react',
        //             entry:'https://unpkg.com/react@16/umd/react.production.min.js',
        //             global:'React'
        //         },{
        //             module:'react-dom',
        //             entry:'https://unpkg.com/react-dom@16/umd/react-dom.production.min.js',
        //             global:'ReactDOM'
        //         }
        //     ]
        // })
```

分离公共包.
```
 optimization: {
        splitChunks: { minSize: 0, cacheGroups: {
        commons: {
                    name: 'commons', 
                    chunks: 'all', 
                    minChunks: 0
                } 
            }
        }
    }

```

### tree shaking (摇树优化).

Tree-shaking 原理
   ES6 模块的特点:
   只能作为模块顶层的语 出现
   import 的模块名只能是字符 常 
   import binding 是 immutable的

代码擦除: uglify 阶段删除无用代码

## 现象:构建后的代码存在大量闭包代码

会导致 么问题?
大量作用域包裹代码,导致体积增 (模块越多越明显)
运 代码时创建的函数作 域变多,内存开销变 

结论:
·被 webpack 转换后的模块会带上 层包裹 
·import 会被转换成 __webpack_require.

## scope hoisting 原理.
原 :将所有模块的代码按照引 顺序放在 个函数作 域 ,然后适当的重命名 
些变 以防 变 名冲突.

### 代码分割的意义
如何使 动态 import?

npm install @babel/plugin-syntax-dynamic-import --save-dev

### webpack 和 eslint 结合.

### webpack 打包库和组件.
* webpack 除 可以 来打包应 ,也可以 来打包 js 库.
* 实现 个 整数加法库的打包.
* ·需要打包压缩版和 压缩版本.
* ·持 AMD/CJS/ESM 模块引用.

### 测试.
. 测试.

### 开发loader.
loader-runner. 开发调试 loader.

### 怎么开发一个异步loader.
同步loader,

异常处理,
throw new exception
返回多个值.


异步的loader 怎么写?
```
const callback = this.async();

```

loader 里面使用缓存.
webpack 中默认开启 this.cacheable 关掉缓存.

loader 如何进行文件输出?

loader 开发雪碧图:

loader 可以用来做什么?

```

```
### 怎么开发一个插件.

插件基本架构是什么样子:
1、loader 是处理静态资源的.
2、插件可以理解为loader 做不了的事情.

class MyPlugin{
    constructor(options){

    }

    apply(complier){

    }
}

MyPlugin.exports = MyPlugin;

插件的使用:
plugins:[new MyPlugin()]

/***
 * 
 *  插件的错误处理
 *  参数校验阶段可以直接throw 的方式抛出.
 *  throw new Error('Error Message')
 *   
 *  通过 compliation 对象的 warings 和 errors 接收.
 * 
 *  插件扩展: 编写插件的插件. 
 *  插件自身也可以通过暴露hooks 的方式进行自身扩展, html-webpack-plugin.
 *  
 *  nodejs 文件压缩成zip包.
 *  要求: 生成的zip 包文件名称可以通过插件传入.
 *  需要使用complier 对象上的特定的Hooks 进行传入.
 *   
 * */


 * 优化构建速度:
    * 分析构建信息. stats. 颗粒度太粗,看不出问题所在.
    * "build:stats":"webpack --config webpack.prod.js --json > stats.json".
    * speed-measure-webpack-plugin. 分析那几个Loader，和插件比较慢.

     速度分析插件作用:
     分析整个打包的插件:

     ```
        const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
        const smp = new SpeedMeasurePlugin();
        const webpackConfig = smp.wrap({
        plugins: [
            new MyPlugin(),
            new MyOtherPlugin()
        ]
        });
     ```

     分析构建体积大的一个瓶颈:
     ```
        const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
        
        module.exports = {
        plugins: [
            new BundleAnalyzerPlugin()
        ]
        }
     ```

     可以分析哪些问题？
     1、依赖的第三方模块文件大小.
     2、业务里面的组件大小.

     ```


     ```

     babel-polyfill 


     优化:
     1、使用高版本的 webpack 和  Node.js
     webpack 4 比 webpack 3 降低了 60%-98% 的提高.


     webpack 4 优化的原因:
     1、V8 带来的优化(for of 替代 forEach、Map 和 Set 替代 Object、includes 替代 indexOf)。
     2、默认使用更快的 md4 hash 算法。
     3、webpacks AST 可以直接从 loader 传递给 AST,减少解析时间。
     4、使用字符串方法替代正则表达式。


    多进程/多实例构建:资源并行解析可选方案.
    1、HappyPack 方案.
    2、原理:每次 webapck 解析一个模块,HappyPack 会将它及它的依赖分配给 worker 线程中。
    3、thread-loader 解析资源.
    ```
     cnpm install thread-loader -D
     {
            test:/.js$/,
            include:path.resolve("src"),
            use:[
                {
                    loader:'thread-loader',
                    options:{
                        workers:3
                    }
                }
                // 'happypack/loader'
            ]
            // use:'babel-loader'
    }
    ```
    多进程/多实例: 并行压缩.
    方案1： 使用 paraller-ugli
    方案2: terser - webpack -plugin 开启parellel 参数.

    ```

    ```

    进一步分包:
    1、预编译资源编译模块.
    DLLPlugin 进行分包. 
    DLLReferencePlugin 对 manifest.json 引用.

    ```
        const path = require('path');
        const webpack = require('webpack');

        module.exports = {
            entry:{
                library:[
                    'react',
                    'react-dom'
                ]
            },
            output:{
                filename:'[name].dll.js',
                path:path.join(__dirname,'build/library'),
                library: '[name]'
            },
            plugins:[
                new webpack.DllPlugin({
                    name:'[name]_[hash]',
                    path:path.join(__dirname,'build/library/[name].json'),
                })
            ]
        }
    ```

    充分利用缓存提升二次构建.
    babel-loader 开启缓存.
    terser-webpack-plugin 开启缓存.
    使用 cache-loader 或者 hard-source-webpack-plugin.

    * 缩小构建目标:
    * 目的:尽可能的少构建模块.
    * 比如 babel-loader 不解析 node_modules.

    减少文件搜索范围
    * 优化 resolve.modules 配置(减少模块搜索层级)
    * 优化 resolve.mainFields 配置.
    * 优化 resolve.extensions 配置.
    * 合理使用 alias.

    webpack 图片优化:
    1、

    动态polyfill.


* 工程化实践:
    * 
    * 
    * 
* 参考文献:
https://www.youtube.com/watch?v=4whiXJP8DxE.

总结我的理解:
1、webpack 核心理念.
  * Entry.
    Entry 用来来制定打包的入口.

  * OutPut.
    Output 来告诉 webpack 如何将编译后的 件输出到磁盘.

  * Loaders.
    webpack 开箱即用只支持 JS 和 JSON 两种文件类型,通过 Loaders 去支持其它文件类型并且把它们转化成有效的模块,并且可以添加到依赖图中.
    本身是一个函数,接受源文件作为参数,返回转换的结果.

    用来做什么:
    css-loader.
    webpack先用css-loader加载器去解析这个文件.
    style-loader
    style-loader生成一个内容为最终解析完的css代码的style标签，放到head标签里.
    less-loader.
    raw-loader.
    ts-loader.
    file-loader.

    开发loader:
    1、loader-runner. 来做测试.
    同步loader.
    ```
    module.exports = function(source){
        const json = JSON.stringify(source)
        .replace('foo','')
        .replace(/\U2028/g,'\\u2028')
        .replace(/\u2029/g,'\\u2029');
        return `export default ${json}`
    }
    ```
    异步loader.

    模式:
    ```
    module.exports = function(source){
        const callback = this.async();

        callback(null,source);
    }
    ```
    研究案例: 
    css-loader.
    css-loader 是通过异步loader 的方式来辨析,postcss 插件来做配合编写.
    https://hellogithub2014.github.io/2019/01/03/webpack-loader/

    file-loader.
    https://github.com/webpack-contrib/file-loader/blob/master/src/index.js

  * Plugins.
    插件用于 bundle 文件的优化,资源管理和环境变注入.作用于整个构建过程.
    没有独立的开发环境.


    插件的基本结构:
    ```
    class MyPlugin{
        apply(complier){
            compiler.hooks.done.tap('My Plugin',()=>{
                console.log('hello world');
            });
        }
    }

    module.exports = MyPlugin;
    ```

    开发插件:
    ```
    module.exports = class MyPlugin{
        constructor(options){
            this.options = options;
        }
        apply(compiler){
            console.log('My plugin is executed');
            console.log('My Plugin options',this.options);
        }
    }
    ```
    /* 
    * 
    *  插件的错误处理
    *  参数校验阶段可以直接throw 的方式抛出.
    *  throw new Error('Error Message')
    *  
    *  通过 compliation 对象的 warings 和 errors 接收.
    *  
    *  插件扩展: 编写插件的插件. 
    *  插件自身也可以通过暴露hooks 的方式进行自身扩展, html-webpack-plugin.
    *  
    *  nodejs 文件压缩成zip包.
    *  要求: 生成的zip 包文件名称可以通过插件传入.
    *  需要使用complier 对象上的特定的Hooks 进行传入.
    *   
    * */
    插件的错误处理.
    复杂的场景:

  * Mode.
    Mode 用来指定当前的构建环境是: production、development 还是none.

2、webpack 基本原理.
   Webpack可以将其理解是一种基于事件流的编程范例,一系列的插件运行.

   基本流程:
   1、初始化配置参数,从entry 开始递归的分析依赖,对每个依赖模块进行build,对模块位置进行解析,开始构建模块.
   2、将loader 加载完成的module 进行编译，生成ast 树
   3、遍历AST,当遇到require 等一些调用表达式,收集依赖.
   4、编译打包,优化.
   5、输出到dist 目录.

   webpack 的模块机制
   · 打包出来的是一个 IIFE (匿名闭包)
   · modules 是一个数组,每一项是一个模块初始化函数
   · __webpack_require 用来加载模块,返回 module.exports 
   · 通过 WEBPACK_REQUIRE_METHOD(0) 启动程序

3、webpack 构建速度优化&体积优化.
    1、体积分析.
        使用webpack 内置的 stats.
        使用speed-measure-webpack-plugin. 分析打包速度的
        使用webpack-bundle-analyzer. 分析体积的.

    2、优化策略.
        使用高版本的webpack和node.js *
        多进程多实例构建. *
        多进程并行压缩代码. *
        预编译资源模块. *
        充分利用缓存提升二次构建速度. *
        缩小构建目标. *
        使用treeShaking 擦除无用的Javascript 和 css .
        使用webpack进行图片压缩.
        使用动态 Polyfill 服务.

4、webpack 工程化实践.
    1、版本管理.
    2、CI/CD.
    3、docker/k8s.

5、如何编写一个webpack.
可以将 ES6 语法转换成 ES5 的语法 ·通过 babylon 生成AST
·通过 babel-core 将AST重新生成源码
可以分析模块之间的依赖关系
· 通过 babel-traverse 的 ImportDeclaration 方法获取依赖属性
生成的 JS 文件可以在浏览器中运行.
