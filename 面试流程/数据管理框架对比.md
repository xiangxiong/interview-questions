> Flux
基本逻辑:
    Flux 应用由三大部分组成 - dispatcher、store 和 view， 其中dispatcher 负责分发事件, store 负责保存数据，同时响应事件并更新数据; view 负责订阅store 中的数据，并使用这些渲染数据的页面.

Flux 模型的解决方案:
https://www.jianshu.com/p/191ca4f3709c

核心思想:
（1）Flux的中心化控制。中心化控制让所有的请求与改变都只能通过action发出，统一由dispatcher进行分配。与MVC数据、逻辑改动源自不同的源头相比，Flux查找问题的困难度要小的多

优  点:
1、View保持整洁，只关心数据，不关心逻辑.
2、中心化控制了所有的数据，发现问题时可以方便查询.

> Redux
1、 原理 (principle)
    工作流程:
    ![image](http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg)

    描述一下: 
      * 组件的状态发生改变，会触发store.dispatch 分发 action,reducers 接收到action 会返回newState,最终会把这个newState 返回给 React.Component.

2、 三大原则:
      1、单一数据源.
        在传统的MVC架构中,我们可以根据需要创建无数个Model,而Model之间可以互相监听、 触发事件甚至循环或嵌套触发事件,这些在 Redux 中都是不允许的.
      2、State是只读的.

      3、使用纯函数来执行修改.

        * 这是Redux与Flux 在表现上的最大不同。在 Flux 中,我们在actionCreator里调用 AppDispatcher.dispatch 方法来触发 action,这样不仅有冗余的代码,而且因为直接修改了 store 中 的数据,将导致无法保存每次数据变化前后的状态.

        * 在 Redux 里,我们通过定义 reducer 来确定状态的修改,而每一个 reducer 都是纯函数,这意 味着它没有副作用,即接受一定的输入,必定会得到一定的输出。这样设计的好处不仅在于 reducer 里对状态的修改变得简单、纯粹、可测试,更有意思的是, Redux 利用每次新返回的状态生成酷炫的时间旅行(time travel)调试方式,让跟踪每一次因为触发 action 而改变状态的结果成为了可能.

3、中间件的基本原理:
    中间件的原理是,它提供的是被发起之后,到达reducer 之前的扩展点.将 store.dispatch 方法进行替换.

4、编写中间件的步骤:
    测试.

5、中间件原理分析:
    要实现一套middleware 主要分为3步: 
    第一步串联 middleware. currying 化.
    const middlewareAPI = {
    getState: store.getState,
    dispatch: (action) => dispatch(action),
    };
    chain = middlewares.map(middleware => middleware(middlewareAPI));

    第二步组合 middleware.
    dispatch = compose(...chain)(store.dispatch);

    组合函数:
    function compose(...funcs) {
        return arg => funcs.reduceRight((composed, f) => f(composed), arg); 6
    }

    组合完成之后:
    dispatch = f1(f2(f3(store.dispatch))));

    这时调用新 dispatch,每一个 middleware 就依次执行了。

    第三步调用执行.
    当我们分发一个 action 时,middleware 通过 next(action) 一层层处理和传递 action 直到 Redux 原生的 dispatch.

6、如何实现中间件:
```
function createThunkMiddleware(extraArgument){
    return ({dispatch,getState}) => next => action =>{
        if(typeof action === 'function'){
            return action(dispatch,getState,extraArgument);
        }
        return next(action);
    }
}
```

> Mobx
1. 官方文档:
https://cn.mobx.js.org/

2、Redux vs mBox

Redux vs Mobx

那么具体到这两种模型，又有一些特定的优缺点呈现出来,先谈谈 Redux 的优势:

数据流流动很自然，因为任何 dispatch 都会导致广播，需要依据对象引用是否变化来控制更新粒度。
如果充分利用时间回溯的特征，可以增强业务的可预测性与错误定位能力。
时间回溯代价很高，因为每次都要更新引用，除非增加代码复杂度，或使用 immutable。
时间回溯的另一个代价是 action 与 reducer 完全脱节，数据流过程需要自行脑补。原因是可回溯必然不能保证引用关系。
引入中间件，其实主要为了解决异步带来的副作用，业务逻辑或多或少参杂着 magic。
但是灵活利用中间件，可以通过约定完成许多复杂的工作。
对 typescript 支持困难.

Mobx:

数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但免去了粒度控制烦恼。
没有时间回溯能力，因为数据只有一份引用。
自始至终一份引用，不需要 immutable，也没有复制对象的额外开销。
没有这样的烦恼，数据流动由函数调用一气呵成，便于调试。
业务开发不是脑力活，而是体力活，少一些 magic，多一些效率。
由于没有 magic，所以没有中间件机制，没法通过 magic 加快工作效率（这里 magic 是指 action 分发到 reducer 的过程）。
完美支持 typescript.

从目前经验来看，我建议前端数据流不太复杂的情况，使用 Mobx，因为更加清晰，也便于维护；如果前端数据流极度复杂，建议谨慎使用 Redux，通过中间件减缓巨大业务复杂度，但还是要做到对开发人员尽量透明，如果可以建议使用 typescript 辅助.

自己的话来讲:
mobx:mutable.
redux:immutable.

mobx: 也是遵循 单向数据流: action=>state=>views.
mobx: 管理状态的基本思路:
1. 定义状态并使其可观察
2. 创建视图以响应状态的变化
3. 更改状态.

第三件要做的事就是更改状态。也就是你的应用究竟要做什么。不像一些其它框架，MobX 不会命令你如何如何去做。 这是最佳实践，但关键要记住一点: MobX 帮助你以一种简单直观的方式来完成工作.  

mbox+redux = vue.

> Dva
https://github.com/sorrycc/blog/issues/1
https://github.com/sorrycc/blog/issues/6


Dva 解决了 redux 什么问题?
1、解决了action不纯粹的问题.
2、选用了 redux+react+saga.
1、文件切换
  redux 的项目通常要分 reducer, action, saga, component
  saga 创建麻烦.
  entry 创建麻烦.
  
> 


