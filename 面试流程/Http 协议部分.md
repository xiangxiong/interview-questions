从输入 URL 到页面加载完成的过程中都发生了什么事情？
http://fex.baidu.com/blog/2014/05/what-happen/

自己总结的语言:
1、第一步是对域名进行dns解析.
2、想服务端发送请求,客户端响应之后，开始渲染。
3、浏览器渲染阶段.
4、显示在界面上.

补充第一阶段:
浏览器输入网址之后便进入页面资源请求过程,这时,浏览器进程会通过进程间通信把URL 请求发送至网络进程,网络进程接收到URL请求之后，会在这里发起真正的URL请求流程.
[缓存的流程是什么?]

https://github.com/amandakelake/blog/issues/41

https://github.com/amandakelake/blog/issues/43

网络进程会查找本地缓存是否缓存了资源. 如果有缓存资源,那么直接返回资源给浏览器进程; 如果在缓存中没有查找到资源, 那么直接进入网络请求流程。这请求前的第一步是要进入dns解析，获取域名的服务器IP地址. 如果是请求协议是HTTPS，那么还要建立TLS连接.

http & https 区别?

https://www.cnblogs.com/jesse131/p/9080925.html

第二阶段补充:
1、便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。
2、接下来就是利用 IP 地址和服务器建立 TCP 连接，连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息.

### 缓存.
说完URL我们说说浏览器缓存,HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为强制缓存，协商缓存.

强制缓存判断HTTP首部字段: cache-control, Expires.
Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用.
cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效. 如果同时存在cache-control和Expires，浏览器总是优先使用cache-control

协商缓存通过HTTP的 last-modified, Etag 字段进行判断.
last-modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地 Last-modified 时间与 if-modified-since 时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存.
Etag：资源的实体标识（哈希字符串),当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304.

Cache-Control:
max-age: 该指令指定从当前请求开始。允许和获取的响应被重用的最长时间单位是秒，
在max-age指定的时间之内，浏览器不会向服务器发送任何请求，也就是说就算网页更新了，浏览器得不到通知，
还会继续使用旧版本的资源,所以慎用.

no-store: 如果服务器在响应中设置了no-store即Cache-Control:no-store,
那浏览器不会存储这次相应的数据，当下次请求时，浏览器会在请求一次，就是说不会对比Etag，不论什么情况都不会缓存.

no-cache: 如果服务器在响应中设置了no-cache即Cache-Control:no-cache,
那么说明浏览器在使用缓存前返对比Etag,返回304就会避免修改(也就是说浏览器会验证有效的信息,才会缓存).

https://blog.csdn.net/weixin_34379433/article/details/88659720

### Http 协议相关.
* 

### DNS 域名解析
我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。
首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。
如果没找到则会查找本地DNS解析器缓存，如果查找到则返回.
如果还是没有找到则会查找本地DNS服务器，如果查找到则返回.
本地DNS服务器 失效的化,从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询.

https://www.cnblogs.com/gopark/p/8430916.html

###  四、TCP连接
在通过第一步的DNS域名解析后，获取到了服务器的IP地址，在获取到IP地址后，便会开始建立一次连接，这是由TCP协议完成的，主要通过三次握手进行连接.

第一次握手:建立连接时,客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认;

第二次握手:服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态;

第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手.

完成三次握手，客户端与服务器开始传送数据.

### DNS:
```
1、
```

### 五、浏览器向服务器发送HTTP请求.
完整的HTTP请求包含请求起始行、请求头部、请求主体三部分.

### 六、浏览器接收响应.
服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。

状态码主要包括以下部分
1xx：指示信息–表示请求已接收，继续处理。
2xx：成功–表示请求已被成功接收、理解、接受。
3xx：重定向–要完成请求必须进行更进一步的操作。
4xx：客户端错误–请求有语法错误或请求无法实现。
5xx：服务器端错误–服务器未能实现合法的请求。
响应头主要由Cache-Control、 Connection、Date、Pragma等组成。
响应体为服务器返回给浏览器的信息，主要由HTML，css，js，图片文件组成.

### 七、页面渲染
如果说响应的内容是HTML文档的话，就需要浏览器进行解析渲染呈现给用户。整个过程涉及两个方面：解析和渲染。在渲染页面之前，需要构建DOM树和CSSOM树.

### 八、关闭TCP连接或继续保持连接
通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK).

(1) 重定向.
(2) 响应数据类型处理.
-----------------------------------------------------------------

第二阶段补充:
浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程.

传输数据、更新状态
8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
8.2 渲染进程接收完数据后，向浏览器发送“确认提交”
8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面.
参考文献:
https://time.geekbang.org/column/article/117637

记忆:
1、解析阶段.
2、响应流程.
3、渲染阶段.

http 1.0 vs http 1.1 vs http 2.0 
HTTPS与HTTP的一些区别
1、HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
2、HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443.

HTTP1.0和HTTP1.1的一些区别:
1、长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应。
2、缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

HTTP2.0性能惊人
1、服务端推送（server push）
2、多路复用（MultiPlexing.

https://juejin.im/entry/5981c5df518825359a2b9476

http 协议类:
POST 和 GET的区别:(重点内容)
1、GET 在浏览器回退时是无害的，而POST会再次提交请求。
2、GET 产生的URL地址可以被隐藏，而POST不可以.
3、GET请求会被浏览器主动缓存，而POST不会，除非手动设置.
4、GET请求只能进行url编码，而POST支持多种编码方式。
5、GET请求参数会被完整保留在浏览器历史记录中，而POST 中的参数不会被保留.
6、GET请求参数会被URL中传送的参数是有长度限制的，而post 没有限制.
7、GET只接受ASCLL字符，而POST没有限制.
8、GET 比POST 更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息.
9、GET 参数通过URL传递，POST 放在Request Body 中.

记忆法: 数字挂钩联想记忆法.
1、

Http 状态码:
1、1xx:指示信息-表示请求已接收，继续处理.
2、2xx: 成功-表示请求已被成功接收.
3、3xx: 重定向-要完成请求必须进行更进一步的操作.
4、4xx: 客户端错误 - 请求有错误或请求无法实现.
403 : 对被请求页面的访问被禁止.
404: 请求资源不存在.

5、5xx: 服务器错误 - 服务器未能实现合法请求.
500:服务器错误.
503:服务器宕机,过载.

Https 的验证流程:
1、客户端发起一个http请求，连接到服务器的443端口.
2、服务端把自己的信息以数字证书的形式返回给客户端.
3、客户利用服务器传过来的信息,验证服务器的合法性.
4、生成随机密码(RSA签名).
5、生成对称加密算法.

https://zhuanlan.zhihu.com/p/60033345
https://segmentfault.com/a/1190000000476876


